# CLAUDE.md

This file is the soul of the DreamTalk agent — everything it needs to work effectively.

## What is DreamTalk?

DreamTalk is a programmatic animation library for Cinema 4D that creates **platonic symbols** — mathematical constructions where the source code IS the thing, not a representation of it.

**The key distinction:**
- Pixel-based AI (Midjourney, DALL-E) → perfects organic/messy imagery in latent space
- DreamTalk AI → perfects mathematical/clean symbolic animation in vector/code space
- They are **complementary**, not competing

A flower of life generated by AI might *look* correct but isn't actually 19 interlocking circles with precise geometric relationships. DreamTalk constructs the mathematical truth.

## DreamTalk in the DreamOS Ecosystem

DreamTalk is the **symbol creation tool** for DreamOS — a decentralized operating system where knowledge is organized as git repositories called **DreamNodes**.

### Core Concepts

- **DreamNode**: A git repository representing a unit of knowledge (idea, symbol, scene, or person)
- **DreamTalk**: The visual symbol that serves as the "face" of a DreamNode (like an app icon or YouTube thumbnail)
- **DreamSong**: Any composition of multiple DreamTalk symbols into a coherent narrative

### The Key Insight

Every DreamNode has a **symbol** (rendered animation) and the **source code that created it**. The source travels with the product. When AI helps you modify a symbol, it reads the DreamTalk code and adjusts it — operating in vector/mathematical space rather than pixel space.

A DreamTalk symbol can represent:
- A mathematical concept (Taylor expansion) — contains the math libraries that created it
- A character (MindVirus) — an animatable creature with multiple behaviors
- A scene (Labyrinth) — a composition of multiple symbols

The symbol **contains the logic that created it**, which can be applied elsewhere.

## Holarchic Structure

### Three Layers

```
┌─────────────────────────────────────────────────────────────────┐
│  LAYER 1: DreamTalk Core Library (this repo)                    │
│  • Primitives: Circle, Cube, Sphere, etc.                       │
│  • Base classes: CustomObject, LineObject, SolidObject          │
│  • Animation system, XPresso, materials                         │
│  • This is VOCABULARY — atoms that don't need sovereignty       │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ submodule
┌─────────────────────────────────────────────────────────────────┐
│  LAYER 2: Sovereign Symbols (each its own DreamNode repo)       │
│  • CustomObjects that MEAN something: MindVirus, Fire           │
│  • Each is a git repo with its own identity                     │
│  • Can compose other symbols as submodules                      │
└─────────────────────────────────────────────────────────────────┘
                              ▲
                              │ submodule
┌─────────────────────────────────────────────────────────────────┐
│  LAYER 3: Scenes/DreamSongs (also DreamNode repos)              │
│  • Compose multiple symbols into narrative animations           │
│  • Renders to full videos, not just looping symbols             │
└─────────────────────────────────────────────────────────────────┘
```

### Sovereign Symbol Structure

```
<SymbolName>/                        # Git repo = DreamNode
├── .udd                             # DreamNode metadata (JSON)
├── README.md                        # Human-readable description
├── <SymbolName>.py                  # Class + standalone scene (if __name__ == "__main__")
├── <SymbolName>.mp4                 # Web distribution
├── <SymbolName>.mov                 # Master with alpha (Keynote compatible)
└── submodules/
    ├── DreamTalk/                   # Core library (always present)
    └── <OtherSymbol>/               # Other sovereign symbols as parts
```

**PascalCase everywhere** — `MindVirus/MindVirus.py` renders `MindVirus.mp4`.

### Single Python File Pattern

```python
# MindVirus.py
from DreamTalk.imports import *

class MindVirus(CustomObject):
    # Class definition with all parameters, parts, relations
    ...

if __name__ == "__main__":
    # Canonical standalone scene for this symbol
    class MindVirusScene(ThreeDScene):
        def construct(self):
            virus = MindVirus(color=BLUE)
            self.play(Create(virus), run_time=3)

    scene = MindVirusScene()
```

- Run directly → renders standalone symbol
- Import from elsewhere → just provides the class

## Development Philosophy: Software Gardening

### Organic Growth Over Pre-Architecture

**We do NOT predict or pre-engineer.** We work the cleanest, most elegant path of least resistance toward the vision. Problems get solved as they arise, and solutions get consolidated into the correct DreamNode at the correct level of the holarchy.

### The Pattern

1. Create what's needed NOW for the current context
2. Work in the higher-level scene/composition
3. Discover what tweaks are needed for that context
4. **Consolidate downward**: Enrich the lower holon's DreamNode with new abilities
5. **Consolidate upward**: Extract reusable patterns to higher abstractions
6. Repeat

Everything grows organically. We're gardening, not engineering.

### DreamNode Enrichment Flow

```
MindVirus (standalone symbol)
    ↓ used in
DoubleWall (discovers: need back-to-back construction)
    ↓ enriches
MindVirus (gains: back-to-back variant)
    ↓ used in
Labyrinth (discovers: need performance-optimized version)
    ↓ enriches
MindVirus (gains: simplified/instanced variant)
```

Each higher context enriches the lower holons with new construction variants. The DreamNode becomes more versatile precisely in the measure that it is actually necessary.

### Where Changes Go (Critical Rule)

**All learning and tweaking consolidates into the Python file of the specific DreamNode.**

When iterating on a symbol (e.g., MindVirus):
- Adjustments to geometry, positioning, parameters → `MindVirus/MindVirus.py`
- New construction variants → `MindVirus/MindVirus.py`
- Bug fixes discovered during use → `MindVirus/MindVirus.py`

**NOT** into:
- The scene script that's using it (that's just instantiation)
- The DreamTalk core library (unless it's truly general infrastructure)
- Scattered helper files

The DreamNode's `.py` file is the single source of truth.

### Abilities Over Separate Classes

When an object has an optional capability (like Fire's glow), add it as a parameter rather than creating a separate class:

```python
fire = Fire(glow=True, brightness=0.8)  # Good
# NOT: PhysicalFire class (redundant)
```

One concept, multiple abilities.

### The Thumbnail Test

At each holon level, the goal is: **create a beautiful DreamTalk render that can serve as the thumbnail** — the sovereign face of that DreamNode.

## MCP Tools

DreamTalk integrates with Cinema 4D via MCP. Five tools handle the complete workflow:

| Tool | Purpose |
|------|---------|
| `run_dreamtalk(path)` | Execute a DreamNode's .py file (clears scene, runs as `__main__`) |
| `describe_scene()` | Universal introspection + auto-diffing for human-in-the-loop workflow |
| `viewport_preview(frames)` | Fast visual feedback (~100-200ms/frame) |
| `rendered_preview(frames)` | Full Sketch & Toon render for line verification |
| `execute_python_script(script)` | Raw Python for R&D/experimentation |

### Core Workflow

```
1. run_dreamtalk(path) → Scene created in C4D
2. viewport_preview() → Quick visual check
3. describe_scene() → See hierarchy, parameters, changes
4. Edit the .py file → All progress accumulates there
5. Repeat until satisfied
6. Commit
```

### Human-in-the-Loop Diffing

`describe_scene()` auto-snapshots the scene state. When the user tweaks something in C4D's UI:
1. Call `describe_scene()` again
2. Changes are automatically detected and surfaced
3. Native C4D parameters that changed are shown with their DescIDs
4. This reveals what needs to be exposed in the DreamTalk interface

## Architecture Reference

### Object Hierarchy

- `ProtoObject` (ABC) → `VisibleObject` → `CustomObject` (composite objects)
- `ProtoObject` (ABC) → `VisibleObject` → `LineObject` (splines)
- `ProtoObject` (ABC) → `VisibleObject` → `SolidObject` (3D objects)

### Key Files

- `scene.py`: Scene classes (`TwoDScene`, `ThreeDScene`)
- `objects/`: All object types
- `animation/`: Animators (`Create`, `Draw`, `Move`, `Scale`, `Rotate`, `Morph`)
- `xpresso/`: Parameter relationships
- `introspection/`: Scene analysis for AI

### Usage

```python
from DreamTalk.imports import *
```

### Constants

Colors: `BLUE`, `RED`, `PURPLE`, `YELLOW`, `GREEN`, `WHITE`, `BLACK`
Math: `PI`, `FPS` (30), `ASPECT_RATIO` (16/9)

## Holarchic Submodule Pattern

Symbols can compose other symbols to infinite depth. Only initialize DreamTalk at the root level:

```bash
git clone <repo>
git submodule update --init submodules/DreamTalk
git submodule update --init submodules/MindVirus  # NOT --recursive
```

Nested DreamTalk submodules remain as pointers (sovereignty preserved) but aren't initialized (no duplication).

## Render Pipeline

| Type | Format | Use Case |
|------|--------|----------|
| Still | PNG (alpha) | Static symbols, thumbnails |
| Dynamic master | MOV ProRes 4444 (alpha) | Keynote, archival |
| Dynamic web | MP4 H.264 | InterBrain, web |

Always use Standard renderer (not Redshift) for Sketch & Toon.

## Cinema 4D Gotchas (Common Bugs)

### MoGraph Cloner Default Mode
**Bug**: Cloner defaults to "Object" mode (mode 0), which requires a target object to clone onto. Without a target, no clones appear.

**Fix**: Always explicitly set cloner mode when creating:
```python
cloner[c4d.ID_MG_MOTIONGENERATOR_MODE] = 2  # Grid Array
# OR
cloner[c4d.ID_MG_MOTIONGENERATOR_MODE] = 1  # Linear (note: use MG_LINEAR_COUNT, not ID constant)
```

Mode values: 0=Object, 1=Linear, 2=Grid Array, 3=Radial, 4=Honeycomb

### Generator Cache Returns None Inside Cloner
**Bug**: When a Python Generator is a child of a MoGraph Cloner, `child.GetCache()` returns `None` for parametric objects (Sphere, Cube, etc.) inside the generator.

**Cause**: The cloner's virtual cloning doesn't fully evaluate nested caches.

**Workarounds**:
1. Use polygon-based primitives (Platonic, or pre-converted objects) instead of parametric primitives
2. Use `SendModelingCommand` to force polygon conversion
3. Check for None and handle gracefully

**Note**: This is a false positive in `describe_scene()` validation - generators inside Cloners legitimately show cache=None for the master template.
